#pragma kernel CSMain

RWTexture2D<float4> Destination;

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
float3 _LightDirection;
float3 _CameraPos;
float4 _Time;
float paramA;
float paramB;

static const float epsilon = 0.001f;
static const float maxDst = 200;
static const int maxStepCount = 250;

float3 hash( float3 x )
{
	x = float3( dot(x,float3(127.1,311.7, 74.7)),
			  dot(x,float3(269.5,183.3,246.1)),
			  dot(x,float3(113.5,271.9,124.6)));

	return frac(sin(x)*43758.5453123);
}
// https://www.shadertoy.com/view/lsKcDD
float3 voronoi(  float3 x )
{
    float3 p = floor( x );
    float3 f = frac( x );

	float id = 0.0;
    float2 res = float2( 100.0,100.0 );
    for( int k=-1; k<=1; k++ )
    for( int j=-1; j<=1; j++ )
    for( int i=-1; i<=1; i++ )
    {
        float3 b = float3( float(i), float(j), float(k) );
        float3 r = float3( b ) - f + hash( p + b );
        float d = dot( r, r );

        if( d < res.x )
        {
			id = dot( p+b, float3(1.0,57.0,113.0 ) );
            res = float2( d, res.x );			
        }
        else if( d < res.y )
        {
            res.y = d;
        }
    }

    return float3( sqrt( res ), abs(id) );
}


struct Ray {
    float3 origin;
    float3 direction;
};

Ray CreateRay(float3 origin, float3 direction) {
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CreateCameraRay(float2 uv) {
    float3 origin = mul(_CameraToWorld, float4(0,0,0,1)).xyz;
    float3 direction = mul(_CameraInverseProjection, float4(uv,0,1)).xyz;
    direction = mul(_CameraToWorld, float4(direction,0)).xyz;
    direction = normalize(direction);
    return CreateRay(origin,direction);
}
float2x2 rot2D(float angle){
    float s = sin(angle);
    float c = cos(angle);
    return float2x2(c,-s,s,c);
}

float smin( float a, float b, float k )
{
    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
    return lerp( b, a, h ) - k*h*(1.0-h);
}
float signedDstToScene(float3 p){
    // p*=1;
    // p.xz = mul( p.xz ,rot2D(p.z/5000));
    // Gyroid
    float dstA= dot(sin(p),cos(p.zxy))/1;
  float dstB= dot(cos(p),1);
    // float2 t=float2(2.0,1.0);
    // float2 q = float2(length(p.xz)-t.x,p.y);
    // return length(q)-t.y;
    // return length(p)-1.0;
    return dstA;
    // return pow((voronoi(p)),3);
    // return smin(dstA, pow(voronoi(p+_Time.y),sin(_Time.y)/2+1.5),1);
    // return smin(dstA, pow(voronoi(p+_Time.y),0),1);
}
float sdfSphere(float3 p){
    return length(p)-5.0;
}
float SceneInfo(float3 p){
    float p1 = signedDstToScene(p);
    float3 origin = mul(_CameraToWorld, float4(1,0,0,1)).xyz;
    float sphere = sdfSphere(_CameraPos);
    return p1;
}
float3 EstimateNormal(float3 p) {
    p.xz = mul( p.xz ,rot2D(p/5000));

    float x = SceneInfo(float3(p.x+epsilon,p.y,p.z)) - SceneInfo(float3(p.x-epsilon,p.y,p.z));
    float y = SceneInfo(float3(p.x,p.y+epsilon,p.z)) - SceneInfo(float3(p.x,p.y-epsilon,p.z));
    float z = SceneInfo(float3(p.x,p.y,p.z+epsilon)) - SceneInfo(float3(p.x,p.y,p.z-epsilon));
    return normalize(float3(x,y,z));
}
//  https://www.shadertoy.com/view/lsKcDD
float calcSoftshadow(  float3 ro,  float3 rd,  float mint,  float tmax,  float w )
{
    ro.xz = mul( ro.xz ,rot2D(ro/5000));

	float res = 1.0;
    float t = mint;
    float ph = 1e10; // big, such that y = 0 on the first iteration
    
    for( int i=0; i<32; i++ )
    {
		float h = SceneInfo( ro + rd*t );

     
        // improved technique
        
        
            // use this if you are getting artifact on the first iteration, or unroll the
            // first iteration out of the loop
            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); 

            float y = h*h/(2.0*ph);
            float d = sqrt(h*h-y*y);
            res = min( res, d/(w*max(0.0,t-y)) );
            ph = h;
        
        
        t += h;
        
        if( res<0.0001 || t>tmax ) break;
        
    }
    res = clamp( res, 0.0, 1.0 );
    return res*res*(3.0-2.0*res);
}


float4x4 rotateY(float theta) {
    float c = cos(theta);
    float s = sin(theta);

return float4x4(
        float4(c, 0, s, 0),
        float4(0, 1, 0, 0),
        float4(-s, 0, c, 0),
        float4(0, 0, 0, 1)
    );
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint width,height;
    Destination.GetDimensions(width, height);

    float2 uv = id.xy / float2(width,height);

    // Background gradient
    float4 result = lerp(float4(51,3,20,1),float4(16,6,28,1),uv.y)/255.0;
    
    // Raymarching:
    Ray ray = CreateCameraRay(uv * 2 - 1);
    float rayDst = 0;
    int marchSteps = 0;

        // ray.origin.xz = mul(ray.origin.xz,rot2D(_Time.x)*1);
        float3 rotRay = ray.origin;
  

    while (rayDst < maxDst && marchSteps < maxStepCount) {
        marchSteps ++;
   

       
        float dst = SceneInfo(ray.origin);

        // Ray has hit a surface
        if (dst <= epsilon) {
        
            // float3 normal = EstimateNormal(ray.origin-ray.direction*epsilon);
            // float3 shadow = calcSoftshadow( ray.origin, _LightDirection, 0.01, 3.0, 0.1);
            // float colourA = saturate(dot(normal,-_LightDirection));

            float3 colourMix = EstimateNormal(ray.origin-ray.direction*epsilon);
            // (colourA) *
            // colourMix = voronoi(ray.origin);
            result = float4(colourMix,1);

            break;
        }

        ray.origin += ray.direction * dst;
        rayDst += dst;

    }

    
    Destination[id.xy] = result;
}
